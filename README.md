# Leetcode Problem Solutions

## Validate Stack Sequences
*Given two sequences pushed and popped with distinct values, return true if and only if this could have been the result of a sequence of push and pop operations on an initially empty stack. This is from https://leetcode.com/problems/validate-stack-sequences/*
> Solution here: [stack-sequence](cpp/validateStackSequence.cpp)  

## Next Greater Element I
*You are given two arrays (without duplicates) nums1 and nums2 where nums1â€™s elements are subset of nums2. Find all the next greater numbers for nums1's elements in the corresponding places of nums2. The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number. This is from https://leetcode.com/problems/next-greater-element-i/*
> Solution here: [next-greater-element](cpp/nextGreaterElement.cpp)

## Remove Outermost Parentheses
*A valid parentheses string is either empty (""), "(" + A + ")", or A + B, where A and B are valid parentheses strings, and + represents string concatenation. For example, "", "()", "(())()", and "(()(()))" are all valid parentheses strings. A valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings. Given a valid parentheses string S, consider its primitive decomposition: S = P_1 + P_2 + ... + P_k, where P_i are primitive valid parentheses strings. Return S after removing the outermost parentheses of every primitive string in the primitive decomposition of S. This is from https://leetcode.com/problems/remove-outermost-parentheses/*
> Solution here: [remove-parantheses](cpp/removeOuterMostParanthesis.cpp)


## Largest Rectangle in Histogram
*Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. This is from https://leetcode.com/problems/largest-rectangle-in-histogram/*
> Solution here: [rectangle-in-histogram](cpp/largestRectancleInHistogram.cpp)


## Daily Temperatures
*Given a list of daily temperatures T, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead. This is from https://leetcode.com/problems/daily-temperatures/*
> Solution here: [daily-temperatures](cpp/dailyTemperature.cpp)


##  Binary Search Tree Iterator
*Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST. Calling next() will return the next smallest number in the BST. This is from https://leetcode.com/problems/binary-search-tree-iterator/*
> Solution here: [bst-iterator](cpp/treeIterator.cpp)


##  Split Linked List in Parts
*Given a (singly) linked list with head node root, write a function to split the linked list into k consecutive linked list "parts".
The length of each part should be as equal as possible: no two parts should have a size differing by more than 1. This may lead to some parts being null.
The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later. This is from https://leetcode.com/problems/split-linked-list-in-parts/*
> Solution here: [split-linked-list](cpp/splitLinkedListInParts.cpp)


## Validate Binary Search Tree
*Given a binary tree, determine if it is a valid binary search tree (BST). This is from https://leetcode.com/problems/validate-binary-search-tree/*
> Solution here: [validate-bst](cpp/validateBinarySearchTree.cpp)


## Populating Next Right Pointers in Each Node
*Given a perfect binary tree, populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. This is from https://leetcode.com/problems/populating-next-right-pointers-in-each-node//*
> Solution here: [populate-next-pointer](cpp/populateNextPointer.cpp)


## Sum of left leaves
*Given a root of binary tree, return the sum of all left leaves. This is from https://leetcode.com/problems/sum-of-left-leaves/*
> Solution here: [sum-of-leaves](cpp/sumOfLeftLeaves.cpp)


## Tilt of Binary Tree
*Given the root of a binary tree, return the sum of every tree node's tilt.
The tilt of a tree node is the absolute difference between the sum of all left subtree node values and all right subtree node values. If a node does not have a left child, then the sum of the left subtree node values is treated as 0. The rule is similar if there the node does not have a right child. This is from https://leetcode.com/problems/binary-tree-tilt/*
> Solution here: [binary-tree-tilt](cpp/findTreeTilt.cpp)


## First Unique Charachter in a string
*Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1. This is from: https://leetcode.com/problems/first-unique-character-in-a-string/*
> Solution here: [first-unique-charachter](cpp/uniqueCharachter.cpp)


## Design a Linked List
*Designing an implementation of Linked List. This is from: https://leetcode.com/problems/design-linked-list/*
> Solution here: [design-linked-list](cpp/designLinkedList.cpp)


## Top K frequent elements
*Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order. This is from: https://leetcode.com/problems/top-k-frequent-elements/*
> Solution here: [top-k-elements](cpp/topKFrequentElements.cpp)


## Increasing Triplet Subsequence
*Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. If no such indices exists, return false. This is from: https://leetcode.com/problems/increasing-triplet-subsequence/*
> Solution here: [increasing-triplet](cpp/increasingTriplet.cpp)

## Rotate Image
*You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise). You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.This is from:https://leetcode.com/problems/rotate-image/*
> Solution here: [inline-rotation](cpp/rotateArray.cpp)

## Longest Palindromic Substring
*Given a string s, return the longest palindromic substring in s. A string is called a palindrome string if the reverse of that string is the same as the original string. This is from: https://leetcode.com/problems/longest-palindromic-substring*
> Solution here: [longest-palindromic-substring](cpp/longestPalindromeSubstring.cpp)

## Find The Original Array of Prefix Xor
*You are given an integer array pref of size n. Find and return the array arr of size n that satisfies: pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i]. Note that ^ denotes the bitwise-xor operation.It can be proven that the answer is unique.This is from: https://leetcode.com/problems/find-the-original-array-of-prefix-xor/*
> Solution here: [Find-The-Original-Array-of-Prefix-Xor](cpp/FindTheOriginalArrayofPrefixXor.cpp)